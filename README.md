# 贪吃蛇

## 简述
对于数据结构课设我们考虑了很久，数据结构可以理解为具体问题抽象数学模型的程序实现方式。   
问题，模型，程序。都是必要的。我们考虑了贪吃蛇这么一个简单的小游戏。最初我们只需要针对蛇的存储结构抽象一个对象，同时对于地图上的点抽象一个对象。然后写一套运行的逻辑即可，这一些似乎是如此的容易。但是倘若问题就那么简单。那显得就很无趣了(为了凑满1200行代码)。我们决定如果我们可以计算出蛇到食物的最短路径，然后由计算机来自动求解最近的路呢？
## 问题
对于上述提出的问题，他的本质其实属于一个动态迷宫出口求解问题，假设蛇头是你的位置，而当前的食物是你的出口，而蛇身与墙壁就是迷宫的障碍物了。关键在于每移动一步障碍就会发生改变。   
对于这个问题我们思考了很久，后来我们"放弃了"。我们发现直接解决这个问题并不简单，所以我们决定循序渐进。`这也就是为什么出现了三个行走模式`
## 详述
### 最初
我们决定无视蛇身，那么这就是一个简单的哈曼顿距离。当然我们只需要使用非常简单的方式行走就可以了，因为在这张图中几乎没有障碍物。也无需使用DFS、BFS
### BFS
虽然最初很容易，但是这根本不是我们的初衷，所以我们决定使用bfs来实现。
+ 首先我们搜索从蛇头到当前食物的直接路径的集合通过bfs。
+ 此时我们抛弃路径对蛇尾变化的影响。
+ 接下来我们找到食物后开始回溯，通过哈曼顿距离来确定当前蛇头的下一步该怎么走。
+ 此时我们让蛇走一步，而这一步已经是当前的最优解了。
+ 我们重复执行上述操作，直到找到了食物。

在实现后我们发现这一思路存在一个致命的问题，那就是我们必须要让蛇头找到食物的路径。但是如果蛇头被"堵死"。那么这个算法就显得力不从心了。
### BFS+ 
遇到上述问题后，我们决定在原有的基础上进行改进。主要就在于堵死情况下如何解决
+ 发生堵死，我们创建虚拟蛇尝试可不可以吃到尾巴
+ 吃到尾巴后我们考虑是否可以吃到食物
+ 如果可以，吃食物。如果不可以，跟着尾巴继续走，直到可以。
+ 如果吃不到尾巴，(由于我们在内层尾巴在最外层),那么开始佛系走，每走一步看看能不能吃到尾巴
+ 如果佛系了还没有，那么我们无能为力了
在这里我们使用了A*算法，负责追尾巴
>一种静态路网中求解最短路径最有效的直接搜索方法，也是解决许多搜索问题的有效算法。算法中的距离估算值与实际值越接近，最终搜索速度越快。

## 关于实现
我们选择了JAVA语言，不同于C语言他封装了大量的基本数据结构，这可以让我们花更多的时间关系这个数学模型本身，而不是关心这些模型中每一个原操作的实现过程。同样的JAVA提供了多线程与面向对象的特性。这让我们将UI的绘图与数据的计算进行了分离。

## 关于UI
JAVA为我们提供了，丰富的UI组建，同样基于JVM的GC机制，也方便我们更加专注于模型的开发，而不是考虑到底要在何时释放这些对象。我们提供了一个简易的UI，有演示模式也有游戏模式。
